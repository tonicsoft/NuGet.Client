<!--
***********************************************************************************************
NuGet.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved. 
***********************************************************************************************
-->
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Load NuGet.Build.Tasks.dll, this can be overridden to use a different version with $(RestoreTaskAssemblyFile) -->
  <PropertyGroup>
    <NugetTaskAssemblyFile Condition="$(NugetPackTaskAssemblyFile) == ''">NuGet.Build.Tasks.Pack.dll</NugetTaskAssemblyFile>
  </PropertyGroup>
  <UsingTask TaskName="NuGet.Build.Tasks.Pack.PackTask" AssemblyFile="$(NugetPackTaskAssemblyFile)" />

  <PropertyGroup>
    <PackageId Condition=" '$(PackageId)' == '' ">$(AssemblyName)</PackageId>
    <PackageVersion Condition=" '$(PackageVersion)' == '' ">$(Version)</PackageVersion>
    <PackageOutputPath Condition=" '$(PackageOutputPath )' == '' ">$(TargetDir)</PackageOutputPath>
    <IncludeContentInPack Condition="'$(IncludeContentInPack)'==''">true</IncludeContentInPack>
    <PackDependsOn>_GetProjectToProjectReferences; _GetReferences; _GetPackageReferences; _GetPackageFilesFromReferencedProjects; _GetSourceFilesForSymbols; _GetTargetPaths</PackDependsOn>
    <Description Condition="'$(Description)'==''">Description</Description>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NoBuild)' == 'true' ">
    <PackDependsOn>$(PackDependsOn)</PackDependsOn>
  </PropertyGroup>
  <PropertyGroup Condition="'$(NoBuild)' != 'true' ">
    <PackDependsOn>Build;$(PackDependsOn)</PackDependsOn>
  </PropertyGroup>
  
  <!--
    ============================================================
    Pack
    Main entry point for packing packages
    ============================================================
  -->
  <Target Name="Pack" DependsOnTargets="$(PackDependsOn)">
    <!-- Call Pack -->
    <PackTask PackItem="$(PackProjectInputFile)"
              PackageFiles="@(_PackageFiles)"
              PackageFilesToExclude="@(_PackageFilesToExclude)"
              PackageVersion="$(PackageVersion)"
              PackageId="$(PackageId)"
              Authors="$(Authors)"
              Description="$(Description)"
              Copyright="$(Copyright)"
              RequireLicenseAcceptance="$(PackageRequireLicenseAcceptance)"
              LicenseUrl="$(PackageLicenseUrl)"
              ProjectUrl="$(PackageProjectUrl)"
              IconUrl="$(PackageIconUrl)"
              ReleaseNotes="$(PackageReleaseNotes)"
              Tags="$(PackageTags)"
              Configuration="$(Configuration)"
              TargetPath="@(_TargetPath)"
              TargetFrameworks="@(TargetFramework)"
              AssemblyName="$(AssemblyName)"
              ProjectReferences="@(_ProjectReferences)"
              PackageOutputPath="$(PackageOutputPath)"
              IncludeSymbols="$(IncludeSymbols)"
              IncludeSource="$(IncludeSource)"
              PackageTypes="$(PackageType)"
              IsTool="$(IsTool)"
              RepositoryUrl="$(RepositoryUrl)"
              RepositoryType="$(RepositoryType)"
              SourceFiles="@(_SourceFiles)"
              NoPackageAnalysis="$(NoPackageAnalysis)"
              MinClientVersion="$(MinClientVersion)"
              Serviceable="$(Serviceable)"
              VersionSuffix ="$(VersionSuffix)"
              AssemblyReferences="@(_References)"
              PackageReferences="@(_PackageReferences)"/>
  </Target>

  <Target Name="_GetTargetPaths">
    <ItemGroup>
      <_TargetPath Include="$(TargetDir)%(TargetFramework.Identity)\$(TargetFileName)"/>
    </ItemGroup>
  </Target>
  <!--
    ============================================================
    _LoadPackGraphEntryPoints
    Find project entry points and load them into items.
    ============================================================
  -->
  <Target Name="_LoadPackInputItems">
    <!-- Allow overriding items with PackProjectFileInput -->
    <PropertyGroup Condition="'$(PackProjectInputFile)' == ''">
      <PackProjectInputFile>$(PackProjectFileInput)</PackProjectInputFile>
    </PropertyGroup>

    <!-- Project case -->
    <PropertyGroup Condition="$(MSBuildProjectFullPath.EndsWith('.csproj')) == 'true' AND '$(PackProjectInputFile)' == ''">
      <PackProjectInputFile>$(MSBuildProjectFullPath)</PackProjectInputFile>
    </PropertyGroup>
  </Target>

  <!--
    ============================================================
    _GetProjectToProjectReferences
    Entry point for generating the project to project references.
    ============================================================
  -->
  <Target Name="_GetProjectToProjectReferences" DependsOnTargets="_LoadPackInputItems">
    
    <!-- Validate -->
    <Error Text="There are no projects to restore!" Condition="$(PackProjectInputFile) == ''"/>

    <!-- Walk the project references for each project -->
    <MsBuild
        Projects="$(PackProjectInputFile)"
        Targets="_RecursivelyGetProjectToProjectReferences"
        BuildInParallel="false"
        Properties="
                %(_MSBuildProjectReferenceExistent.SetConfiguration);
                %(_MSBuildProjectReferenceExistent.SetPlatform);
                CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
                PackGraphWriteEntryPoint=true;
                BuildProjectReferences=false;"
        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_ProjectReferences" />
    </MsBuild>

  </Target>

  <!--
    ============================================================
    _WalkProjectToProjectReferences
    Recursively walk project to project references
    ============================================================
  -->
  <Target Name="_RecursivelyGetProjectToProjectReferences"
      DependsOnTargets="ResolveProjectReferences"
      Returns="@(_ProjectReferences)">

    <ItemGroup Condition="$(PackGraphWriteEntryPoint) == 'true' OR $(IsPackage) == 'false'">
      <!-- Filter out project references that specify ReferenceOutputAssembly=false -->
      <ValidProjectInputForPackGraph Include="@(ProjectReference)"
          Condition=" ('%(ProjectReference.ReferenceOutputAssembly)' == '' OR '%(ProjectReference.ReferenceOutputAssembly)' == 'true')" />
    </ItemGroup>

    <!-- Project to project entry -->
    <ItemGroup Condition = " '$(PackGraphWriteEntryPoint)' == 'false' ">
      <_ProjectReferences
        Include="$(AssemblyName)" Condition=" $(IsPackage) == 'false' " >
        <Type>Project</Type>
        <TargetPath>$(TargetPath)</TargetPath>
        <AssemblyName>$(AssemblyName)</AssemblyName>
        <MSBuildProjectFullPath>$(MSBuildProjectFullPath)</MSBuildProjectFullPath>
      </_ProjectReferences>
      <_ProjectReferences
        Include="$(PackageId)" Condition=" $(IsPackage) == 'true' OR $(IsPackage) == '' ">
        <Type>Package</Type>
        <PackageId>$(PackageId)</PackageId>
        <PackageVersion>$(PackageVersion)</PackageVersion>
      </_ProjectReferences>
        
    </ItemGroup>

    <!-- Recurse into referenced projects -->
    <MSBuild
      Projects="@(ValidProjectInputForPackGraph)"
      Targets="_RecursivelyGetProjectToProjectReferences"
      Properties="
            %(_MSBuildProjectReferenceExistent.SetConfiguration);
            %(_MSBuildProjectReferenceExistent.SetPlatform);
            IsPackage=%(ValidProjectInputForPackGraph.TreatAsPackageReference);
            PackGraphWriteEntryPoint=false;
            BuildProjectReferences=false"
      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_ProjectReferences" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GetPackageFilesFromReferencedProjects
    Entry point for generating the project to project references.
    ============================================================
  -->
  <Target Name="_GetPackageFilesFromReferencedProjects" DependsOnTargets="_LoadPackInputItems">
    <Message Text="Package File Entry Point : $(PackProjectInputFile)" Importance="High"/>

    <ItemGroup>
      <_PackageFilesToExclude Include="@(Content)" Condition="'%(Content.Pack)' == 'false'"/>
    </ItemGroup>
    <!-- Walk the project references for each project -->
    <MsBuild
        Projects="$(PackProjectInputFile)"
        Targets="_RecursivelyGetPackageFilesFromReferencedProjects"
        BuildInParallel="false"
        Properties="
                %(_MSBuildProjectReferenceExistent.SetConfiguration);
                %(_MSBuildProjectReferenceExistent.SetPlatform);
                IsPackage=false;
                CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);"
        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_PackageFiles" />
    </MsBuild>

  </Target>

  <!--
    ============================================================
    _RecursivelyGetPackageFilesFromReferencedProjects
    Recursively walk project to project references to get content files which should be packed
    ============================================================
  -->
  <Target Name="_RecursivelyGetPackageFilesFromReferencedProjects"
      DependsOnTargets="ResolveProjectReferences"
      Condition="$(IncludeContentInPack) == 'true'"
      Returns="@(_PackageFiles)">

    <Message Text="Currently in project : $(MSBuildProjectFullPath)" Importance="High"/>
    <ItemGroup Condition="$(IsPackage) == 'false'">
      <!-- Filter out project references that specify ReferenceOutputAssembly=false -->
      <ValidProjectInputForPackGraph Include="@(ProjectReference)"
          Condition=" %(ProjectReference.ReferenceOutputAssembly) == '' OR %(ProjectReference.ReferenceOutputAssembly) == 'true' " />
    </ItemGroup>

    <!-- Project to project entry -->
    <!-- Include PackageFiles and Content of the project being packed -->
    <ItemGroup Condition="'$(IsPackage)' == 'false'">
      <_PackageFiles Include="@(Content)" Condition=" %(Content.Pack) != 'false' " />
      <_PackageFiles Include="@(Compile)" Condition=" %(Compile.Pack) == 'true' " />
      <_PackageFiles Include="@(None)" Condition=" %(None.Pack) == 'true' " />
    </ItemGroup>

    <!-- Recurse into referenced projects -->
    <MSBuild
      Projects="@(ValidProjectInputForPackGraph)"
      Targets="_RecursivelyGetPackageFilesFromReferencedProjects"
      Properties="
            %(_MSBuildProjectReferenceExistent.SetConfiguration);
            %(_MSBuildProjectReferenceExistent.SetPlatform);
            IsPackage=%(ValidProjectInputForPackGraph.TreatAsPackageReference);
            BuildProjectReferences=false;"
      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_PackageFiles" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    _GetSourceFilesForSymbols
    Entry point for getting the source files for the project & it's references.
    ============================================================
  -->
  <Target Name="_GetSourceFilesForSymbols" Condition="$(IncludeSource) == 'true'" DependsOnTargets="_LoadPackInputItems">

    <!-- Validate -->
    <Error Text="Could not find a csproj file" Condition="$(PackProjectInputFile) == ''"/>

    <!-- Walk the project references for each project -->
    <MsBuild
        Projects="$(PackProjectInputFile)"
        Targets="_RecursivelyGetSourceFilesForSymbols"
        BuildInParallel="false"
        Properties="
                %(_MSBuildProjectReferenceExistent.SetConfiguration);
                %(_MSBuildProjectReferenceExistent.SetPlatform);
                CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
                BuildProjectReferences=false;
                IsPackage=false;"
        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_SourceFiles" />
    </MsBuild>

  </Target>

  <!--
    ============================================================
    _RecursivelyGetSourceFilesForSymbols
    Recursively walk project to project references
    ============================================================
  -->
  <Target Name="_RecursivelyGetSourceFilesForSymbols"
      DependsOnTargets="ResolveProjectReferences"
      Returns="@(_SourceFiles)">

    <ItemGroup Condition="$(IsPackage) == 'false'">
      <!-- Filter out project references that specify ReferenceOutputAssembly=false -->
      <ValidProjectInputForPackGraph Include="@(ProjectReference)"
          Condition=" %(ProjectReference.ReferenceOutputAssembly) == '' OR %(ProjectReference.ReferenceOutputAssembly) == 'true' " />
    </ItemGroup>

    <!-- Project to project entry -->
    <ItemGroup>
      <_SourceFiles Include="@(Compile)" Condition=" $(IsPackage) == 'false' " />
    </ItemGroup>

    <!-- Recurse into referenced projects -->
    <MSBuild
      Projects="@(ValidProjectInputForPackGraph)"
      Targets="_RecursivelyGetSourceFilesForSymbols"
      Properties="
            %(_MSBuildProjectReferenceExistent.SetConfiguration);
            %(_MSBuildProjectReferenceExistent.SetPlatform);
            BuildProjectReferences=false;
            IsPackage=%(ValidProjectInputForPackGraph.TreatAsPackageReference);"
      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_SourceFiles" />
    </MSBuild>
  </Target>
  
<!--
    ============================================================
    _GetReferences
    Entry point for getting the source files for the project & it's references.
    ============================================================
  -->
  <Target Name="_GetReferences" DependsOnTargets="_LoadPackInputItems">

    <!-- Validate -->
    <Error Text="Could not find a csproj file" Condition="$(PackProjectInputFile) == ''"/>

    <!-- Walk the project references for each project -->
    <MsBuild
        Projects="$(PackProjectInputFile)"
        Targets="_RecursivelyGetReferences"
        BuildInParallel="false"
        Properties="
                %(_MSBuildProjectReferenceExistent.SetConfiguration);
                %(_MSBuildProjectReferenceExistent.SetPlatform);
                CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
                BuildProjectReferences=false;
                IsPackage=false;"
        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_References" />
    </MsBuild>

  </Target>

  <!--
    ============================================================
    _RecursivelyGetReferences
    Recursively walk project to project references to obtain a list of <Reference>
    ============================================================
  -->
  <Target Name="_RecursivelyGetReferences"
      DependsOnTargets="ResolveProjectReferences"
      Returns="@(_References)">

    <ItemGroup Condition="$(IsPackage) == 'false'">
      <!-- Filter out project references that specify ReferenceOutputAssembly=false -->
      <ValidProjectInputForPackGraph Include="@(ProjectReference)"
          Condition=" %(ProjectReference.ReferenceOutputAssembly) == '' OR %(ProjectReference.ReferenceOutputAssembly) == 'true' " />
    </ItemGroup>

    <!-- Project to project entry -->
    <ItemGroup>
      <_References Include="@(Reference)" Condition=" $(IsPackage) == 'false' " />
    </ItemGroup>

    <!-- Recurse into referenced projects -->
    <MSBuild
      Projects="@(ValidProjectInputForPackGraph)"
      Targets="_RecursivelyGetReferences"
      Properties="
            %(_MSBuildProjectReferenceExistent.SetConfiguration);
            %(_MSBuildProjectReferenceExistent.SetPlatform);
            BuildProjectReferences=false;
            IsPackage=%(ValidProjectInputForPackGraph.TreatAsPackageReference);"
      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_References" />
    </MSBuild>
  </Target>
  
<!--
    ============================================================
    _GetPackageReferences
    Entry point for getting the package references for a project and it's references
    ============================================================
  -->
  <Target Name="_GetPackageReferences" DependsOnTargets="_LoadPackInputItems">

    <!-- Validate -->
    <Error Text="Could not find a csproj file" Condition="$(PackProjectInputFile) == ''"/>

    <!-- Walk the project references for each project -->
    <MsBuild
        Projects="$(PackProjectInputFile)"
        Targets="_RecursivelyGetPackageReferences"
        BuildInParallel="false"
        Properties="
                %(_MSBuildProjectReferenceExistent.SetConfiguration);
                %(_MSBuildProjectReferenceExistent.SetPlatform);
                CustomAfterMicrosoftCommonTargets=$(MSBuildThisFileFullPath);
                BuildProjectReferences=false;
                IsPackage=false;"
        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_PackageReferences" />
    </MsBuild>

  </Target>

  <!--
    ============================================================
    _RecursivelyGetPackageReferences
    Recursively walk project to project references to get a list of package references
    ============================================================
  -->
  <Target Name="_RecursivelyGetPackageReferences"
      DependsOnTargets="ResolveProjectReferences"
      Returns="@(_PackageReferences)">

    <ItemGroup Condition="$(IsPackage) == 'false'">
      <!-- Filter out project references that specify ReferenceOutputAssembly=false -->
      <ValidProjectInputForPackGraph Include="@(ProjectReference)"
          Condition=" %(ProjectReference.ReferenceOutputAssembly) == '' OR %(ProjectReference.ReferenceOutputAssembly) == 'true' " />
    </ItemGroup>

    <!-- Project to project entry -->
    <ItemGroup>
      <_PackageReferences Include="@(PackageReference)" Condition=" $(IsPackage) == 'false' " />
    </ItemGroup>

    <!-- Recurse into referenced projects -->
    <MSBuild
      Projects="@(ValidProjectInputForPackGraph)"
      Targets="_RecursivelyGetPackageReferences"
      Properties="
            %(_MSBuildProjectReferenceExistent.SetConfiguration);
            %(_MSBuildProjectReferenceExistent.SetPlatform);
            BuildProjectReferences=false;
            IsPackage=%(ValidProjectInputForPackGraph.TreatAsPackageReference);"
      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">

      <Output
          TaskParameter="TargetOutputs"
          ItemName="_PackageReferences" />
    </MSBuild>
  </Target>
  
</Project>